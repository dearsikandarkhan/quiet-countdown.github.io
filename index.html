<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Growth Journey</title>
    <style>
        :root {
            --text-primary: rgba(255, 255, 255, 0.95);
            --text-secondary: rgba(255, 255, 255, 0.75);
            --text-muted: rgba(255, 255, 255, 0.55);
            --card-bg: rgba(0, 0, 0, 0.25);
            --card-border: rgba(255, 255, 255, 0.1);
            --border-radius: 16px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(180deg, #1a2f1a 0%, #0d1f0d 100%);
        }

        #renderCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            z-index: 1;
        }

        .ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding: 2rem;
            padding-bottom: max(2rem, env(safe-area-inset-bottom));
        }

        .content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            max-width: 600px;
            width: 100%;
        }

        .countdown-container {
            display: flex;
            gap: clamp(0.5rem, 2vw, 1rem);
            flex-wrap: wrap;
            justify-content: center;
            pointer-events: auto;
        }

        .time-card {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: var(--border-radius);
            padding: clamp(0.9rem, 2.5vw, 1.25rem) clamp(1.1rem, 3vw, 1.75rem);
            border: 1px solid var(--card-border);
            min-width: clamp(68px, 17vw, 88px);
            text-align: center;
            transition: transform 0.3s ease, background 0.3s ease;
        }

        .time-card:hover {
            background: rgba(0, 0, 0, 0.35);
            transform: translateY(-2px);
        }

        .time-value {
            font-size: clamp(1.6rem, 5vw, 2.25rem);
            font-weight: 300;
            color: var(--text-primary);
            line-height: 1;
            font-variant-numeric: tabular-nums;
            letter-spacing: -0.02em;
        }

        .time-label {
            font-size: clamp(0.55rem, 1.3vw, 0.7rem);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.12em;
            margin-top: 0.4rem;
            font-weight: 500;
        }

        .quote-container {
            text-align: center;
            padding: 0 1rem;
            opacity: 0;
            animation: fadeIn 2s ease-out 1s forwards;
        }

        .quote-text {
            font-size: clamp(0.85rem, 2.2vw, 1rem);
            color: var(--text-secondary);
            font-style: italic;
            line-height: 1.7;
            font-weight: 300;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .progress-bar-container {
            width: 100%;
            max-width: 300px;
            height: 3px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, rgba(129, 199, 132, 0.8), rgba(102, 187, 106, 0.9));
            border-radius: 2px;
            transition: width 1s ease-out;
            box-shadow: 0 0 10px rgba(129, 199, 132, 0.5);
        }

        .progress-text {
            font-size: clamp(0.7rem, 1.6vw, 0.8rem);
            color: var(--text-muted);
            letter-spacing: 0.05em;
        }

        .sound-toggle {
            position: fixed;
            top: max(1.25rem, env(safe-area-inset-top));
            right: 1.25rem;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--card-border);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            z-index: 100;
            pointer-events: auto;
        }

        .sound-toggle:hover {
            background: rgba(0, 0, 0, 0.4);
            transform: scale(1.05);
        }

        .sound-toggle:active {
            transform: scale(0.95);
        }

        .music-indicator {
            position: fixed;
            top: max(1.25rem, env(safe-area-inset-top));
            right: 4.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--card-border);
            font-size: 0.7rem;
            color: var(--text-muted);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .music-indicator.visible {
            opacity: 1;
        }

        .complete-message {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            text-align: center;
        }

        .complete-message.visible {
            display: flex;
            animation: fadeIn 1.5s ease-out;
        }

        .complete-text {
            font-size: clamp(1.2rem, 3.5vw, 1.6rem);
            font-weight: 300;
            color: var(--text-primary);
            line-height: 1.6;
            text-shadow: 0 2px 15px rgba(0, 0, 0, 0.5);
        }

        .complete-emoji {
            font-size: 2rem;
            animation: float 3s ease-in-out infinite;
        }

        .hidden {
            display: none !important;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #1a2f1a 0%, #0d1f0d 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }

        .loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: rgba(129, 199, 132, 0.8);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1.5rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        @media (max-width: 480px) {
            .ui-layer {
                padding: 1.5rem;
                padding-bottom: max(1.5rem, env(safe-area-inset-bottom));
            }
            
            .content-wrapper {
                gap: 1.25rem;
            }
        }

        @media (min-height: 700px) {
            .ui-layer {
                padding-bottom: max(3rem, env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <p class="loading-text">Preparing your journey</p>
    </div>

    <canvas id="renderCanvas"></canvas>

    <div class="ui-layer">
        <div class="content-wrapper">
            <section class="countdown-container" id="countdown">
                <article class="time-card">
                    <div class="time-value" id="days">--</div>
                    <div class="time-label">Days</div>
                </article>
                <article class="time-card">
                    <div class="time-value" id="hours">--</div>
                    <div class="time-label">Hours</div>
                </article>
                <article class="time-card">
                    <div class="time-value" id="minutes">--</div>
                    <div class="time-label">Minutes</div>
                </article>
                <article class="time-card">
                    <div class="time-value" id="seconds">--</div>
                    <div class="time-label">Seconds</div>
                </article>
            </section>

            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <p class="progress-text" id="progressText">Day 1 of 44</p>

            <section class="quote-container">
                <p class="quote-text" id="quoteText"></p>
            </section>

            <section class="complete-message" id="complete">
                <span class="complete-emoji">ðŸŒ±</span>
                <p class="complete-text">It's time.<br>Walk forward calmly.</p>
            </section>
        </div>
    </div>

    <div class="music-indicator" id="musicIndicator">â™ª Forest Dawn</div>
    <button class="sound-toggle" id="soundToggle" aria-label="Toggle ambient sound">ðŸ”‡</button>

    <script>
        (function() {
            const TOTAL_DAYS = 44;
            const startDate = new Date();
            startDate.setHours(0, 0, 0, 0);
            
            const targetDate = new Date(startDate);
            targetDate.setDate(targetDate.getDate() + TOTAL_DAYS);
            targetDate.setHours(18, 0, 0, 0);

            const quotes = [
                "The only way to make sense out of change is to plunge into it, move with it, and join the dance.",
                "Growth is painful. Change is painful. But nothing is as painful as staying stuck somewhere you don't belong.",
                "What lies behind us and what lies before us are tiny matters compared to what lies within us.",
                "The secret of change is to focus all of your energy not on fighting the old, but on building the new.",
                "You don't have to see the whole staircase, just take the first step.",
                "Within you there is a stillness and a sanctuary to which you can retreat at any time.",
                "The wound is the place where the light enters you.",
                "Be patient with yourself. You are growing stronger every day.",
                "Let go of who you think you're supposed to be; embrace who you are.",
                "Your calm mind is the ultimate weapon against your challenges.",
                "The best time to plant a tree was twenty years ago. The second best time is now.",
                "Peace comes from within. Do not seek it without.",
                "The quieter you become, the more you can hear.",
                "New beginnings are often disguised as painful endings.",
                "Trust the wait. Embrace the uncertainty. Enjoy the beauty of becoming.",
                "Courage is not the absence of fear, but rather the judgment that something else is more important.",
                "In the middle of difficulty lies opportunity.",
                "When I let go of what I am, I become what I might be.",
                "Life begins at the end of your comfort zone.",
                "Surrender to what is. Let go of what was. Have faith in what will be.",
                "Not all those who wander are lost.",
                "A tree that is unbending is easily broken. Bend and flow.",
                "The present moment is the only moment available to us, and it is the door to all moments.",
                "You are never too old to set another goal or to dream a new dream.",
                "Where there is no struggle, there is no strength.",
                "Freedom is not worth having if it does not include the freedom to make mistakes.",
                "Every moment is a fresh beginning.",
                "The only journey is the one within.",
                "You are allowed to be both a masterpiece and a work in progress simultaneously.",
                "Sometimes the smallest step in the right direction ends up being the biggest step of your life."
            ];

            const musicVariants = [
                { name: "Forest Dawn", baseFreq: 65.41, chordType: "major", tempo: 0.08 },
                { name: "Mountain Stream", baseFreq: 55.00, chordType: "sus4", tempo: 0.06 },
                { name: "Evening Meadow", baseFreq: 73.42, chordType: "minor", tempo: 0.1 },
                { name: "Zen Garden", baseFreq: 49.00, chordType: "fifth", tempo: 0.05 }
            ];

            let currentMusicIndex = Math.floor(Math.random() * musicVariants.length);

            const daysEl = document.getElementById('days');
            const hoursEl = document.getElementById('hours');
            const minutesEl = document.getElementById('minutes');
            const secondsEl = document.getElementById('seconds');
            const countdownEl = document.getElementById('countdown');
            const completeEl = document.getElementById('complete');
            const quoteText = document.getElementById('quoteText');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const soundToggle = document.getElementById('soundToggle');
            const loadingScreen = document.getElementById('loadingScreen');
            const musicIndicator = document.getElementById('musicIndicator');

            quoteText.textContent = `"${quotes[Math.floor(Math.random() * quotes.length)]}"`;

            let audioContext = null;
            let isPlaying = false;
            let masterGain = null;
            let activeOscillators = [];
            let activeGains = [];

            function getChordFrequencies(baseFreq, chordType) {
                const ratios = {
                    major: [1, 1.25, 1.5, 2],
                    minor: [1, 1.2, 1.5, 2],
                    sus4: [1, 1.333, 1.5, 2],
                    fifth: [1, 1.5, 2, 3]
                };
                return ratios[chordType].map(r => baseFreq * r);
            }

            function initAudio() {
                if (audioContext) return;
                
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGain = audioContext.createGain();
                    masterGain.gain.value = 0;
                    masterGain.connect(audioContext.destination);
                    
                    createMusicVariant(currentMusicIndex);
                    createNatureSounds();
                } catch (e) {
                    console.log('Audio not available');
                }
            }

            function createMusicVariant(index) {
                const variant = musicVariants[index];
                const frequencies = getChordFrequencies(variant.baseFreq, variant.chordType);
                const volumes = [0.08, 0.05, 0.04, 0.03];

                activeOscillators.forEach(osc => {
                    try { osc.stop(); } catch(e) {}
                });
                activeOscillators = [];
                activeGains = [];

                frequencies.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    filter.type = 'lowpass';
                    filter.frequency.value = 300 + i * 50;
                    filter.Q.value = 0.5;
                    
                    gain.gain.value = volumes[i];
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    
                    osc.start();
                    activeOscillators.push(osc);
                    activeGains.push({ gain, baseVol: volumes[i], phase: i * 1.5 });
                });

                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = variant.tempo;
                lfoGain.gain.value = 0.3;
                lfo.connect(lfoGain);
                
                activeGains.forEach(({ gain }) => {
                    lfoGain.connect(gain.gain);
                });
                
                lfo.start();
                activeOscillators.push(lfo);

                musicIndicator.textContent = `â™ª ${variant.name}`;
            }

            function createNatureSounds() {
                const bufferSize = 2 * audioContext.sampleRate;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const whiteNoise = audioContext.createBufferSource();
                whiteNoise.buffer = noiseBuffer;
                whiteNoise.loop = true;
                
                const windFilter = audioContext.createBiquadFilter();
                windFilter.type = 'bandpass';
                windFilter.frequency.value = 300;
                windFilter.Q.value = 0.5;
                
                const windGain = audioContext.createGain();
                windGain.gain.value = 0.015;
                
                whiteNoise.connect(windFilter);
                windFilter.connect(windGain);
                windGain.connect(masterGain);
                
                whiteNoise.start();

                function modulateWind() {
                    if (!isPlaying) {
                        requestAnimationFrame(modulateWind);
                        return;
                    }
                    const time = Date.now() / 1000;
                    windFilter.frequency.value = 250 + Math.sin(time * 0.3) * 150;
                    windGain.gain.value = 0.01 + Math.sin(time * 0.2) * 0.008;
                    requestAnimationFrame(modulateWind);
                }
                modulateWind();

                setInterval(() => {
                    if (!isPlaying || !audioContext || Math.random() > 0.25) return;
                    
                    const birdOsc = audioContext.createOscillator();
                    const birdGain = audioContext.createGain();
                    const birdFilter = audioContext.createBiquadFilter();
                    
                    birdOsc.type = 'sine';
                    const baseFreq = 1200 + Math.random() * 800;
                    birdOsc.frequency.value = baseFreq;
                    
                    birdFilter.type = 'bandpass';
                    birdFilter.frequency.value = baseFreq;
                    birdFilter.Q.value = 5;
                    
                    birdGain.gain.value = 0;
                    
                    birdOsc.connect(birdFilter);
                    birdFilter.connect(birdGain);
                    birdGain.connect(masterGain);
                    
                    const now = audioContext.currentTime;
                    const pattern = Math.floor(Math.random() * 3);
                    
                    if (pattern === 0) {
                        birdGain.gain.setValueAtTime(0, now);
                        birdGain.gain.linearRampToValueAtTime(0.02, now + 0.05);
                        birdOsc.frequency.linearRampToValueAtTime(baseFreq * 1.3, now + 0.1);
                        birdGain.gain.linearRampToValueAtTime(0.015, now + 0.15);
                        birdOsc.frequency.linearRampToValueAtTime(baseFreq * 0.85, now + 0.3);
                        birdGain.gain.linearRampToValueAtTime(0, now + 0.5);
                        birdOsc.start(now);
                        birdOsc.stop(now + 0.6);
                    } else if (pattern === 1) {
                        for (let i = 0; i < 3; i++) {
                            const t = now + i * 0.15;
                            birdGain.gain.setValueAtTime(0, t);
                            birdGain.gain.linearRampToValueAtTime(0.015, t + 0.03);
                            birdGain.gain.linearRampToValueAtTime(0, t + 0.1);
                        }
                        birdOsc.start(now);
                        birdOsc.stop(now + 0.6);
                    } else {
                        birdGain.gain.setValueAtTime(0, now);
                        birdGain.gain.linearRampToValueAtTime(0.018, now + 0.1);
                        birdOsc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, now + 0.2);
                        birdGain.gain.linearRampToValueAtTime(0, now + 0.4);
                        birdOsc.start(now);
                        birdOsc.stop(now + 0.5);
                    }
                }, 5000);

                setInterval(() => {
                    if (!isPlaying || !audioContext || Math.random() > 0.15) return;
                    
                    const cricketOsc = audioContext.createOscillator();
                    const cricketGain = audioContext.createGain();
                    
                    cricketOsc.type = 'sine';
                    cricketOsc.frequency.value = 4000 + Math.random() * 1000;
                    cricketGain.gain.value = 0;
                    
                    cricketOsc.connect(cricketGain);
                    cricketGain.connect(masterGain);
                    
                    const now = audioContext.currentTime;
                    const chirps = 2 + Math.floor(Math.random() * 4);
                    
                    for (let i = 0; i < chirps; i++) {
                        const t = now + i * 0.08;
                        cricketGain.gain.setValueAtTime(0, t);
                        cricketGain.gain.linearRampToValueAtTime(0.008, t + 0.02);
                        cricketGain.gain.linearRampToValueAtTime(0, t + 0.05);
                    }
                    
                    cricketOsc.start(now);
                    cricketOsc.stop(now + chirps * 0.1);
                }, 8000);
            }

            function switchMusic() {
                if (!audioContext) return;
                currentMusicIndex = (currentMusicIndex + 1) % musicVariants.length;
                createMusicVariant(currentMusicIndex);
                
                musicIndicator.classList.add('visible');
                setTimeout(() => musicIndicator.classList.remove('visible'), 2000);
            }

            function toggleSound() {
                if (!audioContext) initAudio();
                
                isPlaying = !isPlaying;
                soundToggle.textContent = isPlaying ? 'ðŸ”Š' : 'ðŸ”‡';
                
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                if (masterGain) {
                    masterGain.gain.setTargetAtTime(isPlaying ? 1 : 0, audioContext.currentTime, 0.5);
                }

                if (isPlaying) {
                    musicIndicator.classList.add('visible');
                    setTimeout(() => musicIndicator.classList.remove('visible'), 2000);
                }
            }

            soundToggle.addEventListener('click', toggleSound);
            soundToggle.addEventListener('dblclick', switchMusic);

            function padZero(num) {
                return num.toString().padStart(2, '0');
            }

            let currentGrowth = 0;
            let targetGrowth = 0;
            let currentDay = 1;

            function calculateDayAndProgress() {
                const now = new Date();
                const todayStart = new Date();
                todayStart.setHours(0, 0, 0, 0);
                
                const msPerDay = 24 * 60 * 60 * 1000;
                const daysPassed = Math.floor((now - startDate) / msPerDay);
                
                currentDay = Math.min(Math.max(1, daysPassed + 1), TOTAL_DAYS);
                
                const dayProgress = (now - todayStart) / msPerDay;
                const overallProgress = (currentDay - 1 + dayProgress) / TOTAL_DAYS;
                
                return Math.max(0, Math.min(1, overallProgress));
            }

            function updateCountdown() {
                const now = new Date();
                const remaining = targetDate - now;
                
                const progress = calculateDayAndProgress();
                targetGrowth = progress;
                
                progressBar.style.width = `${progress * 100}%`;
                progressText.textContent = `Day ${currentDay} of ${TOTAL_DAYS} Â· ${Math.round(progress * 100)}% grown`;

                if (remaining <= 0) {
                    countdownEl.classList.add('hidden');
                    document.querySelector('.progress-bar-container').classList.add('hidden');
                    progressText.classList.add('hidden');
                    document.querySelector('.quote-container').classList.add('hidden');
                    completeEl.classList.add('visible');
                    targetGrowth = 1;
                    return false;
                }

                const days = Math.floor(remaining / (1000 * 60 * 60 * 24));
                const hours = Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);

                daysEl.textContent = days;
                hoursEl.textContent = padZero(hours);
                minutesEl.textContent = padZero(minutes);
                secondsEl.textContent = padZero(seconds);

                return true;
            }

            const canvas = document.getElementById('renderCanvas');
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            let engine, scene, camera, tree;
            let trunkMesh, branches = [], leaves = [], flowers = [];

            function loadBabylon() {
                const script = document.createElement('script');
                script.src = 'https://cdn.babylonjs.com/babylon.js';
                script.onload = function() {
                    initScene();
                };
                script.onerror = function() {
                    console.log('Babylon.js failed to load, using fallback');
                    initFallback();
                };
                document.head.appendChild(script);
            }

            function initScene() {
                try {
                    engine = new BABYLON.Engine(canvas, true, { 
                        preserveDrawingBuffer: true, 
                        stencil: true,
                        antialias: true
                    });

                    scene = new BABYLON.Scene(engine);
                    scene.clearColor = new BABYLON.Color4(0.06, 0.1, 0.05, 1);
                    scene.ambientColor = new BABYLON.Color3(0.15, 0.2, 0.15);
                    scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
                    scene.fogDensity = 0.008;
                    scene.fogColor = new BABYLON.Color3(0.1, 0.15, 0.08);

                    camera = new BABYLON.ArcRotateCamera(
                        "camera",
                        Math.PI / 2,
                        Math.PI / 2.8,
                        isMobile ? 18 : 14,
                        new BABYLON.Vector3(0, 3, 0),
                        scene
                    );
                    camera.lowerRadiusLimit = 8;
                    camera.upperRadiusLimit = 30;
                    camera.lowerBetaLimit = 0.2;
                    camera.upperBetaLimit = Math.PI / 2.05;
                    camera.attachControl(canvas, true);
                    camera.wheelPrecision = 50;
                    camera.panningSensibility = 0;

                    const sun = new BABYLON.DirectionalLight(
                        "sun",
                        new BABYLON.Vector3(-0.4, -0.8, -0.3),
                        scene
                    );
                    sun.intensity = 2.0;
                    sun.diffuse = new BABYLON.Color3(1, 0.95, 0.88);

                    const ambient = new BABYLON.HemisphericLight(
                        "ambient",
                        new BABYLON.Vector3(0, 1, 0),
                        scene
                    );
                    ambient.intensity = 0.7;
                    ambient.diffuse = new BABYLON.Color3(0.5, 0.6, 0.5);
                    ambient.groundColor = new BABYLON.Color3(0.1, 0.15, 0.08);

                    let shadowGenerator = null;
                    if (!isMobile) {
                        shadowGenerator = new BABYLON.ShadowGenerator(2048, sun);
                        shadowGenerator.useBlurExponentialShadowMap = true;
                        shadowGenerator.blurKernel = 64;
                        shadowGenerator.setDarkness(0.25);
                    }

                    createGround(shadowGenerator);
                    createTree(shadowGenerator);
                    createParticles();

                    let lastTime = performance.now();
                    let cameraAngle = Math.PI / 2;

                    engine.runRenderLoop(function() {
                        const currentTime = performance.now();
                        const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
                        lastTime = currentTime;

                        cameraAngle += deltaTime * 0.03;
                        camera.alpha = Math.PI / 2 + Math.sin(cameraAngle) * 0.2;
                        camera.beta = Math.PI / 2.8 + Math.sin(cameraAngle * 0.5) * 0.03;

                        animateTree(deltaTime, currentTime / 1000);
                        scene.render();
                    });

                    window.addEventListener('resize', function() {
                        engine.resize();
                    });

                    setTimeout(() => {
                        loadingScreen.classList.add('fade-out');
                        updateCountdown();
                        setInterval(updateCountdown, 1000);
                    }, 800);

                } catch (e) {
                    console.error('Scene init error:', e);
                    initFallback();
                }
            }

            function createGround(shadowGenerator) {
                const ground = BABYLON.MeshBuilder.CreateGround("ground", {
                    width: 80,
                    height: 80,
                    subdivisions: 4
                }, scene);

                const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
                groundMat.diffuseColor = new BABYLON.Color3(0.08, 0.15, 0.05);
                groundMat.specularColor = new BABYLON.Color3(0.02, 0.03, 0.01);
                ground.material = groundMat;
                ground.receiveShadows = true;

                const hillPositions = [
                    { x: -15, z: -20, size: 8, height: 3 },
                    { x: 20, z: -15, size: 6, height: 2 },
                    { x: -20, z: 15, size: 10, height: 4 }
                ];

                hillPositions.forEach((hill, i) => {
                    const hillMesh = BABYLON.MeshBuilder.CreateSphere(`hill${i}`, {
                        diameter: hill.size * 2,
                        segments: 16
                    }, scene);
                    hillMesh.scaling.y = hill.height / hill.size;
                    hillMesh.position = new BABYLON.Vector3(hill.x, -hill.size * 0.3, hill.z);
                    hillMesh.material = groundMat;
                });

                const grassCount = isMobile ? 60 : 120;
                for (let i = 0; i < grassCount; i++) {
                    const dist = 1.5 + Math.random() * 25;
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * dist;
                    const z = Math.sin(angle) * dist;
                    
                    const blade = BABYLON.MeshBuilder.CreatePlane(`grass${i}`, {
                        width: 0.05 + Math.random() * 0.05,
                        height: 0.1 + Math.random() * 0.25
                    }, scene);
                    
                    blade.position = new BABYLON.Vector3(x, 0.08, z);
                    blade.rotation.y = Math.random() * Math.PI * 2;
                    blade.rotation.x = -0.1;
                    
                    const grassMat = new BABYLON.StandardMaterial(`grassMat${i}`, scene);
                    grassMat.diffuseColor = new BABYLON.Color3(
                        0.1 + Math.random() * 0.1,
                        0.3 + Math.random() * 0.25,
                        0.08 + Math.random() * 0.05
                    );
                    grassMat.specularColor = BABYLON.Color3.Black();
                    grassMat.backFaceCulling = false;
                    blade.material = grassMat;
                }
            }

            function createTree(shadowGenerator) {
                tree = new BABYLON.TransformNode("tree", scene);

                const trunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
                trunkMat.diffuseColor = new BABYLON.Color3(0.28, 0.18, 0.1);
                trunkMat.specularColor = new BABYLON.Color3(0.05, 0.04, 0.02);

                trunkMesh = BABYLON.MeshBuilder.CreateCylinder("trunk", {
                    diameterTop: 0.15,
                    diameterBottom: 0.4,
                    height: 1,
                    tessellation: 12
                }, scene);
                trunkMesh.material = trunkMat;
                trunkMesh.parent = tree;
                trunkMesh.position.y = 0.5;
                
                if (shadowGenerator) {
                    shadowGenerator.addShadowCaster(trunkMesh);
                }

                const branchLevels = [
                    { day: 5, configs: [
                        { height: 0.6, angle: 0.7, rotation: 0, length: 0.8 },
                        { height: 0.6, angle: 0.7, rotation: Math.PI, length: 0.8 }
                    ]},
                    { day: 10, configs: [
                        { height: 0.7, angle: 0.6, rotation: Math.PI * 0.5, length: 1.0 },
                        { height: 0.7, angle: 0.6, rotation: Math.PI * 1.5, length: 1.0 }
                    ]},
                    { day: 15, configs: [
                        { height: 0.8, angle: 0.5, rotation: Math.PI * 0.25, length: 1.2 },
                        { height: 0.8, angle: 0.5, rotation: Math.PI * 1.25, length: 1.2 }
                    ]},
                    { day: 20, configs: [
                        { height: 0.85, angle: 0.45, rotation: Math.PI * 0.75, length: 1.1 },
                        { height: 0.85, angle: 0.45, rotation: Math.PI * 1.75, length: 1.1 }
                    ]},
                    { day: 25, configs: [
                        { height: 0.9, angle: 0.4, rotation: Math.PI * 0.1, length: 1.0 },
                        { height: 0.9, angle: 0.4, rotation: Math.PI * 1.1, length: 1.0 }
                    ]},
                    { day: 30, configs: [
                        { height: 0.92, angle: 0.35, rotation: Math.PI * 0.6, length: 0.9 },
                        { height: 0.92, angle: 0.35, rotation: Math.PI * 1.6, length: 0.9 }
                    ]},
                    { day: 35, configs: [
                        { height: 0.95, angle: 0.3, rotation: Math.PI * 0.35, length: 0.8 }
                    ]},
                    { day: 40, configs: [
                        { height: 0.97, angle: 0.25, rotation: Math.PI * 1.35, length: 0.7 }
                    ]}
                ];

                branchLevels.forEach((level) => {
                    level.configs.forEach((config, i) => {
                        const branch = BABYLON.MeshBuilder.CreateCylinder(`branch_d${level.day}_${i}`, {
                            diameterTop: 0.03,
                            diameterBottom: 0.08,
                            height: config.length,
                            tessellation: 8
                        }, scene);
                        
                        branch.material = trunkMat;
                        branch.parent = tree;
                        branch.rotation.z = config.angle;
                        branch.rotation.y = config.rotation;
                        
                        branch.scaling = new BABYLON.Vector3(0, 0, 0);
                        branch.config = config;
                        branch.unlockDay = level.day;
                        
                        if (shadowGenerator) {
                            shadowGenerator.addShadowCaster(branch);
                        }
                        
                        branches.push(branch);
                    });
                });

                const leafCount = isMobile ? 80 : 150;
                const leafUnlockStart = 8;
                
                for (let i = 0; i < leafCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI * 0.5;
                    const radius = 0.5 + Math.random() * 2.5;
                    
                    const leafSize = 0.15 + Math.random() * 0.25;
                    const leaf = BABYLON.MeshBuilder.CreateDisc(`leaf${i}`, {
                        radius: leafSize,
                        tessellation: 6
                    }, scene);
                    
                    const leafMat = new BABYLON.StandardMaterial(`leafMat${i}`, scene);
                    const greenBase = 0.25 + Math.random() * 0.35;
                    leafMat.diffuseColor = new BABYLON.Color3(
                        0.1 + Math.random() * 0.15,
                        greenBase,
                        0.08 + Math.random() * 0.1
                    );
                    leafMat.specularColor = new BABYLON.Color3(0.03, 0.06, 0.02);
                    leafMat.backFaceCulling = false;
                    leaf.material = leafMat;
                    
                    leaf.parent = tree;
                    
                    const basePos = {
                        x: Math.sin(phi) * Math.cos(theta) * radius,
                        y: 0.85 + Math.cos(phi) * radius * 0.5,
                        z: Math.sin(phi) * Math.sin(theta) * radius
                    };
                    
                    leaf.position = new BABYLON.Vector3(basePos.x, basePos.y, basePos.z);
                    leaf.rotation.y = Math.random() * Math.PI * 2;
                    leaf.rotation.x = Math.random() * 0.8 - 0.4;
                    
                    leaf.scaling = new BABYLON.Vector3(0, 0, 0);
                    leaf.basePos = basePos;
                    leaf.phase = Math.random() * Math.PI * 2;
                    leaf.unlockDay = leafUnlockStart + Math.floor((i / leafCount) * (TOTAL_DAYS - leafUnlockStart - 5));
                    
                    if (shadowGenerator && i < 20) {
                        shadowGenerator.addShadowCaster(leaf);
                    }
                    
                    leaves.push(leaf);
                }

                const flowerCount = isMobile ? 8 : 15;
                for (let i = 0; i < flowerCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI * 0.4;
                    const radius = 1.5 + Math.random() * 1.5;
                    
                    const flower = BABYLON.MeshBuilder.CreateDisc(`flower${i}`, {
                        radius: 0.08 + Math.random() * 0.06,
                        tessellation: 8
                    }, scene);
                    
                    const flowerMat = new BABYLON.StandardMaterial(`flowerMat${i}`, scene);
                    const flowerColors = [
                        new BABYLON.Color3(1, 0.85, 0.9),
                        new BABYLON.Color3(1, 0.95, 0.8),
                        new BABYLON.Color3(0.95, 0.9, 1)
                    ];
                    flowerMat.diffuseColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    flowerMat.emissiveColor = flowerMat.diffuseColor.scale(0.2);
                    flowerMat.backFaceCulling = false;
                    flower.material = flowerMat;
                    
                    flower.parent = tree;
                    
                    const basePos = {
                        x: Math.sin(phi) * Math.cos(theta) * radius,
                        y: 0.9 + Math.cos(phi) * radius * 0.4,
                        z: Math.sin(phi) * Math.sin(theta) * radius
                    };
                    
                    flower.position = new BABYLON.Vector3(basePos.x, basePos.y, basePos.z);
                    flower.rotation = new BABYLON.Vector3(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );
                    
                    flower.scaling = new BABYLON.Vector3(0, 0, 0);
                    flower.basePos = basePos;
                    flower.phase = Math.random() * Math.PI * 2;
                    flower.unlockDay = 35 + Math.floor((i / flowerCount) * 9);
                    
                    flowers.push(flower);
                }
            }

            function createParticles() {
                const particleSystem = new BABYLON.ParticleSystem("particles", isMobile ? 30 : 80, scene);
                
                const particleTexture = new BABYLON.DynamicTexture("particleTex", 32, scene);
                const ctx = particleTexture.getContext();
                const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, "rgba(200, 230, 180, 0.9)");
                gradient.addColorStop(0.5, "rgba(180, 220, 160, 0.4)");
                gradient.addColorStop(1, "rgba(160, 200, 140, 0)");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 32, 32);
                particleTexture.update();
                
                particleSystem.particleTexture = particleTexture;
                particleSystem.emitter = new BABYLON.Vector3(0, 5, 0);
                
                particleSystem.minEmitBox = new BABYLON.Vector3(-3, -1, -3);
                particleSystem.maxEmitBox = new BABYLON.Vector3(3, 2, 3);
                
                particleSystem.color1 = new BABYLON.Color4(0.8, 0.9, 0.7, 0.3);
                particleSystem.color2 = new BABYLON.Color4(0.7, 0.85, 0.6, 0.2);
                particleSystem.colorDead = new BABYLON.Color4(0.6, 0.8, 0.5, 0);
                
                particleSystem.minSize = 0.03;
                particleSystem.maxSize = 0.1;
                particleSystem.minLifeTime = 5;
                particleSystem.maxLifeTime = 10;
                particleSystem.emitRate = isMobile ? 5 : 12;
                
                particleSystem.gravity = new BABYLON.Vector3(0, -0.01, 0);
                particleSystem.direction1 = new BABYLON.Vector3(-0.2, 0.2, -0.2);
                particleSystem.direction2 = new BABYLON.Vector3(0.2, 0.5, 0.2);
                
                particleSystem.minEmitPower = 0.03;
                particleSystem.maxEmitPower = 0.15;
                
                particleSystem.start();
            }

            function animateTree(deltaTime, time) {
                if (!tree || !trunkMesh) return;
                
                currentGrowth += (targetGrowth - currentGrowth) * deltaTime * 0.3;
                const g = currentGrowth;
                const day = currentDay;

                const maxTrunkHeight = 6;
                const trunkProgress = Math.min(1, day / 20);
                const trunkHeight = 1 + trunkProgress * (maxTrunkHeight - 1);
                const trunkThickness = 0.8 + trunkProgress * 0.4;
                
                trunkMesh.scaling.y = trunkHeight;
                trunkMesh.scaling.x = trunkThickness;
                trunkMesh.scaling.z = trunkThickness;
                trunkMesh.position.y = trunkHeight / 2;

                branches.forEach((branch) => {
                    if (day >= branch.unlockDay) {
                        const branchAge = (day - branch.unlockDay) / 5;
                        const scale = Math.min(1, branchAge);
                        branch.scaling = new BABYLON.Vector3(scale, scale, scale);
                        branch.position.y = branch.config.height * trunkHeight;
                        branch.position.x = Math.sin(branch.config.rotation) * 0.1 * trunkThickness;
                        branch.position.z = Math.cos(branch.config.rotation) * 0.1 * trunkThickness;
                    }
                });

                const windStrength = 0.06 * g;
                
                leaves.forEach((leaf) => {
                    if (day >= leaf.unlockDay) {
                        const leafAge = (day - leaf.unlockDay) / 3;
                        const scale = Math.min(1, leafAge);
                        leaf.scaling = new BABYLON.Vector3(scale, scale, scale);
                        
                        const sway = Math.sin(time * 1.5 + leaf.phase) * windStrength;
                        const bob = Math.cos(time * 0.8 + leaf.phase * 0.5) * windStrength * 0.5;
                        
                        leaf.position.x = leaf.basePos.x * trunkThickness + sway;
                        leaf.position.y = leaf.basePos.y * trunkHeight + bob;
                        leaf.position.z = leaf.basePos.z * trunkThickness + Math.cos(time + leaf.phase) * windStrength * 0.4;
                        
                        leaf.rotation.z = Math.sin(time * 1.2 + leaf.phase) * 0.15 * scale;
                    } else {
                        leaf.scaling = new BABYLON.Vector3(0, 0, 0);
                    }
                });

                flowers.forEach((flower) => {
                    if (day >= flower.unlockDay) {
                        const flowerAge = (day - flower.unlockDay) / 2;
                        const scale = Math.min(1, flowerAge);
                        flower.scaling = new BABYLON.Vector3(scale, scale, scale);
                        
                        const sway = Math.sin(time * 1.2 + flower.phase) * windStrength * 0.8;
                        const bob = Math.cos(time * 0.6 + flower.phase) * windStrength * 0.4;
                        
                        flower.position.x = flower.basePos.x * trunkThickness + sway;
                        flower.position.y = flower.basePos.y * trunkHeight + bob;
                        flower.position.z = flower.basePos.z * trunkThickness + Math.cos(time * 0.9 + flower.phase) * windStrength * 0.3;
                    } else {
                        flower.scaling = new BABYLON.Vector3(0, 0, 0);
                    }
                });

                tree.rotation.z = Math.sin(time * 0.2) * 0.005 * g;
                tree.rotation.x = Math.cos(time * 0.15) * 0.003 * g;
            }

            function initFallback() {
                const ctx = canvas.getContext('2d');
                let animTime = 0;
                
                function drawFallback() {
                    animTime += 0.016;
                    const w = canvas.width = window.innerWidth * window.devicePixelRatio;
                    const h = canvas.height = window.innerHeight * window.devicePixelRatio;
                    
                    const scale = window.devicePixelRatio;
                    ctx.setTransform(scale, 0, 0, scale, 0, 0);
                    
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, '#1a2f1a');
                    gradient.addColorStop(1, '#0d1f0d');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                    
                    const centerX = width / 2;
                    const baseY = height * 0.75;
                    
                    currentGrowth += (targetGrowth - currentGrowth) * 0.02;
                    const g = currentGrowth;
                    const day = currentDay;
                    
                    const trunkProgress = Math.min(1, day / 20);
                    const trunkHeight = 50 + trunkProgress * 150;
                    const trunkWidth = 12 + trunkProgress * 18;
                    
                    ctx.fillStyle = '#3d2817';
                    ctx.beginPath();
                    ctx.moveTo(centerX - trunkWidth / 2, baseY);
                    ctx.quadraticCurveTo(
                        centerX - trunkWidth / 3,
                        baseY - trunkHeight / 2,
                        centerX - trunkWidth / 4,
                        baseY - trunkHeight
                    );
                    ctx.lineTo(centerX + trunkWidth / 4, baseY - trunkHeight);
                    ctx.quadraticCurveTo(
                        centerX + trunkWidth / 3,
                        baseY - trunkHeight / 2,
                        centerX + trunkWidth / 2,
                        baseY
                    );
                    ctx.fill();
                    
                    if (day >= 5) {
                        const branchCount = Math.min(8, Math.floor((day - 5) / 5) + 1);
                        ctx.strokeStyle = '#3d2817';
                        ctx.lineWidth = 4;
                        
                        for (let i = 0; i < branchCount; i++) {
                            const branchY = baseY - trunkHeight * (0.4 + i * 0.08);
                            const direction = i % 2 === 0 ? 1 : -1;
                            const branchLength = 30 + Math.random() * 20;
                            
                            ctx.beginPath();
                            ctx.moveTo(centerX, branchY);
                            ctx.quadraticCurveTo(
                                centerX + direction * branchLength * 0.5,
                                branchY - 10,
                                centerX + direction * branchLength,
                                branchY - 20
                            );
                            ctx.stroke();
                        }
                    }
                    
                    if (day >= 8) {
                        const leafProgress = Math.min(1, (day - 8) / 30);
                        const leafLayers = Math.floor(3 + leafProgress * 5);
                        
                        for (let layer = 0; layer < leafLayers; layer++) {
                            const layerY = baseY - trunkHeight - layer * 20;
                            const layerSize = (60 + g * 80) * (1 - layer * 0.12);
                            const green = 60 + layer * 25;
                            
                            const wobble = Math.sin(animTime * 1.5 + layer) * 3;
                            
                            ctx.fillStyle = `rgb(${30 + layer * 8}, ${green}, ${25 + layer * 5})`;
                            ctx.beginPath();
                            ctx.ellipse(
                                centerX + wobble,
                                layerY,
                                layerSize,
                                layerSize * 0.65,
                                0, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                    
                    if (day >= 35) {
                        const flowerCount = Math.floor((day - 35) / 2) + 1;
                        for (let i = 0; i < Math.min(flowerCount, 10); i++) {
                            const angle = (i / 10) * Math.PI * 2;
                            const radius = 40 + Math.random() * 30;
                            const fx = centerX + Math.cos(angle) * radius;
                            const fy = baseY - trunkHeight - 30 + Math.sin(angle) * radius * 0.5;
                            
                            ctx.fillStyle = `rgba(255, ${220 + Math.random() * 35}, ${230 + Math.random() * 25}, 0.9)`;
                            ctx.beginPath();
                            ctx.arc(fx, fy, 4 + Math.random() * 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    requestAnimationFrame(drawFallback);
                }
                
                drawFallback();
                
                setTimeout(() => {
                    loadingScreen.classList.add('fade-out');
                    updateCountdown();
                    setInterval(updateCountdown, 1000);
                }, 500);
            }

            loadBabylon();
        })();
    </script>
</body>
</html>
